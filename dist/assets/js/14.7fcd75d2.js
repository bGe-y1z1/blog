(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{459:function(t,a,v){"use strict";v.r(a);var _=v(49),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"微前端的设计思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微前端的设计思路"}},[t._v("#")]),t._v(" 微前端的设计思路")]),t._v(" "),v("p",[t._v("在 toB 的前端开发工作中，我们往往就会遇到如下困境：")]),t._v(" "),v("p",[t._v("工程越来越大，打包越来越慢\n团队人员多，产品功能复杂，代码冲突频繁、影响面大\n内心想做 SaaS 产品，但客户总是要做定制化")]),t._v(" "),v("h2",{attrs:{id:"为什么需要微前端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要微前端"}},[t._v("#")]),t._v(" 为什么需要微前端")]),t._v(" "),v("ul",[v("li",[t._v("遗留系统迁移 解决遗留系统，才是人们采用微前端方案最重要的原因。")]),t._v(" "),v("li",[t._v("聚合前端应用 微服务架构，可以解耦后端服务间依赖。而微前端，则关注于聚合前端应用。")]),t._v(" "),v("li",[t._v("热闹驱动开发 新的技术，既然很热闹，那么就学吧。")])]),t._v(" "),v("h2",{attrs:{id:"微前端的好处"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微前端的好处"}},[t._v("#")]),t._v(" 微前端的好处")]),t._v(" "),v("ul",[v("li",[t._v("应用自治 只需要遵循统一的接口规范或者框架，以便于系统集成到一起，相互之间是不存在依赖关系的。")]),t._v(" "),v("li",[t._v("单一职责 每个前端应用可以只关注于自己所需要完成的功能")]),t._v(" "),v("li",[t._v("技术栈无关 你可以使用 Angular 的同时，又可以使用 React 和 Vue。")])]),t._v(" "),v("div",{staticClass:"custom-block danger"},[v("p",[t._v("过多的技术栈的缺点：\n应用的拆分基础依赖于基础设施的构建，一旦大量应用依赖于同一基础设施，那么维护变成了一个挑战。\n拆分的粒度越小，便意味着架构变得复杂、维护成本变高。\n技术栈一旦多样化，便意味着技术栈混乱。")])]),t._v(" "),v("h2",{attrs:{id:"如何设计微前端架构？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何设计微前端架构？"}},[t._v("#")]),t._v(" 如何设计微前端架构？")]),t._v(" "),v("h3",{attrs:{id:"设计理念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计理念"}},[t._v("#")]),t._v(" 设计理念")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("中心化：\n应用注册表。这个应用注册表拥有每个应用及对应的入口。在前端领域里，入口的直接表现形式可以是路由，又或者对应的应用映射。")])]),t._v(" "),v("li",[v("p",[t._v("标识化应用。\n我们需要一个标识符来标识不同的应用，以便于在安装、卸载的时候，能寻找到指定的应用。")])]),t._v(" "),v("li",[v("p",[t._v("应用生命周期管理。")])]),t._v(" "),v("li",[v("p",[t._v("高内聚，低耦合。")])])]),t._v(" "),v("h3",{attrs:{id:"生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),v("p",[t._v("前端微架构与后端微架构的最大不同之处，也在于此——生命周期。微前端应用作为一个客户端应用，每个应用都拥有自己的生命周期：")]),t._v(" "),v("ul",[v("li",[t._v("Load，决定加载哪个应用，并绑定生命周期")]),t._v(" "),v("li",[t._v("bootstrap，获取静态资源")]),t._v(" "),v("li",[t._v("Mount，安装应用，如创建 DOM 节点")]),t._v(" "),v("li",[t._v("Unload，删除应用的生命周期")]),t._v(" "),v("li",[t._v("Unmount，卸载应用，如删除 DOM 节点、取消事件绑定")])]),t._v(" "),v("p",[t._v("这部分的内容事实上，也就是微前端的一个难点所在，如何以合适的方式来加载应用——毕竟每个前端框架都各自不同，其所需要的加载方式也是不同的。当我们决定支持多个框架的时候，便需要在这一部分进入更细致的研究。")]),t._v(" "),v("h3",{attrs:{id:"技术方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#技术方式"}},[t._v("#")]),t._v(" 技术方式")]),t._v(" "),v("h4",{attrs:{id:"路由分发式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#路由分发式"}},[t._v("#")]),t._v(" 路由分发式")]),t._v(" "),v("p",[t._v("通过 node koa 框架搭建路由分发")]),t._v(" "),v("p",[v("img",{attrs:{src:"/mfe/mfe1.jpeg",alt:"mfe"}}),t._v(" "),v("img",{attrs:{src:"/mfe/mfe2.jpeg",alt:"mfe"}})]),t._v(" "),v("h4",{attrs:{id:"前端微服务化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前端微服务化"}},[t._v("#")]),t._v(" 前端微服务化")]),t._v(" "),v("p",[t._v("前端微服务化，是微服务架构在前端的实施，每个前端应用都是完全独立（技术栈、开发、部署、构建独立）、自主运行的，最后通过模块化的方式组合出完整的前端应用")]),t._v(" "),v("p",[v("img",{attrs:{src:"/mfe/mfe3.jpeg",alt:"mfe"}})]),t._v(" "),v("h4",{attrs:{id:"npm-私有库-插入和组件公用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#npm-私有库-插入和组件公用"}},[t._v("#")]),t._v(" npm 私有库 插入和组件公用")]),t._v(" "),v("p",[t._v("搭建 npm 私有仓库来管理个加载业务组件或者 UI 组件，实现微应用的共享和统一规范化")])])}),[],!1,null,null,null);a.default=s.exports}}]);