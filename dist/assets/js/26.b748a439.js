(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{470:function(t,e,r){"use strict";r.r(e);var a=r(49),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"proxy-代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy-代理"}},[t._v("#")]),t._v(" proxy 代理")]),t._v(" "),r("p",[t._v("用于修改某些操作的默认行为，等同于在语言层面上做修改，")]),t._v(" "),r("p",[r("code",[t._v("proxy")]),t._v(" 可以理解成 在目标对象之前架设一层拦截，外界对该对象的访问必须经过这层拦截，因此提供了一种机制，对外界的访问进行过滤和拦截")]),t._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" proxy "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Proxy")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" handler"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),r("p",[r("code",[t._v("Proxy")]),t._v(" 对象的所有用法，都是上面这种形式，不同的只是 "),r("code",[t._v("handler")]),t._v(" 参数的写法。其中，"),r("code",[t._v("new Proxy()")]),t._v("表示生成一个 "),r("code",[t._v("Proxy")]),t._v(" 实例，"),r("code",[t._v("target")]),t._v(" 参数表示所要拦截的目标对象，"),r("code",[t._v("handler")]),t._v(" 参数也是一个对象，用来定制拦截行为。")]),t._v(" "),r("h3",{attrs:{id:"hander-拦截行为"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hander-拦截行为"}},[t._v("#")]),t._v(" hander 拦截行为")]),t._v(" "),r("h4",{attrs:{id:"get-target-propkey-receiver"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#get-target-propkey-receiver"}},[t._v("#")]),t._v(" get(target, propKey, receiver)")]),t._v(" "),r("p",[r("code",[t._v("get")]),t._v(" 方法用于拦截某个属性的读取操作")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("ul",[r("li",[t._v("可继承")]),t._v(" "),r("li",[t._v("可以链式调用")])])]),t._v(" "),r("h4",{attrs:{id:"set-target-propkey-value-receiver"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#set-target-propkey-value-receiver"}},[t._v("#")]),t._v(" set(target, propKey, value, receiver)")]),t._v(" "),r("p",[r("code",[t._v("set")]),t._v(" 方法用来拦截某个属性的赋值操作。")]),t._v(" "),r("h4",{attrs:{id:"has-target-propkey"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#has-target-propkey"}},[t._v("#")]),t._v(" has(target, propKey)")]),t._v(" "),r("p",[t._v("拦截 propKey in proxy 的操作，以及对象的 hasOwnProperty 方法，返回一个布尔值。")]),t._v(" "),r("div",{staticClass:"custom-block danger"},[r("p",[t._v("另外，虽然 for...in 循环也用到了 in 运算符，但是 has 拦截对 for...in 循环不生效。")])]),t._v(" "),r("h4",{attrs:{id:"apply-target-object-args"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#apply-target-object-args"}},[t._v("#")]),t._v(" apply(target, object, args)")]),t._v(" "),r("p",[t._v("拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。")]),t._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" handler "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("target"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ctx"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("Reflect")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("arguments"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),r("p",[t._v("apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。")]),t._v(" "),r("h4",{attrs:{id:"construct-target-args"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#construct-target-args"}},[t._v("#")]),t._v(" construct(target, args)")]),t._v(" "),r("p",[t._v("拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args)。")]),t._v(" "),r("div",{staticClass:"custom-block danger"},[r("p",[t._v("construct 方法返回的必须是一个对象，否则会报错。")])]),t._v(" "),r("h4",{attrs:{id:"deleteproperty-target-propkey"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#deleteproperty-target-propkey"}},[t._v("#")]),t._v(" deleteProperty(target, propKey)")]),t._v(" "),r("p",[t._v("拦截 delete proxy[propKey]的操作，返回一个布尔值。")]),t._v(" "),r("h4",{attrs:{id:"ownkeys-target"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ownkeys-target"}},[t._v("#")]),t._v(" ownKeys(target)")]),t._v(" "),r("p",[t._v("拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而 Object.keys()仅返回对象可遍历的属性。")]),t._v(" "),r("h4",{attrs:{id:"getownpropertydescriptor-target-propkey"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#getownpropertydescriptor-target-propkey"}},[t._v("#")]),t._v(" getOwnPropertyDescriptor(target, propKey)")]),t._v(" "),r("p",[t._v("拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。")]),t._v(" "),r("h4",{attrs:{id:"defineproperty-target-propkey-propdesc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#defineproperty-target-propkey-propdesc"}},[t._v("#")]),t._v(" defineProperty(target, propKey, propDesc)")]),t._v(" "),r("p",[t._v("拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。")]),t._v(" "),r("h4",{attrs:{id:"preventextensions-target"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#preventextensions-target"}},[t._v("#")]),t._v(" preventExtensions(target)")]),t._v(" "),r("p",[t._v("拦截 Object.preventExtensions(proxy)，返回一个布尔值。")]),t._v(" "),r("h4",{attrs:{id:"getprototypeof-target"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#getprototypeof-target"}},[t._v("#")]),t._v(" getPrototypeOf(target)")]),t._v(" "),r("p",[t._v("拦截 Object.getPrototypeOf(proxy)，返回一个对象。")]),t._v(" "),r("h4",{attrs:{id:"isextensible-target"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#isextensible-target"}},[t._v("#")]),t._v(" isExtensible(target)")]),t._v(" "),r("p",[t._v("拦截 Object.isExtensible(proxy)，返回一个布尔值。")]),t._v(" "),r("h4",{attrs:{id:"setprototypeof-target-proto"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#setprototypeof-target-proto"}},[t._v("#")]),t._v(" setPrototypeOf(target, proto)")]),t._v(" "),r("p",[t._v("拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。")]),t._v(" "),r("p",[t._v("如果目标对象是函数，那么还有两种额外操作可以拦截。")]),t._v(" "),r("h4",{attrs:{id:"this-问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#this-问题"}},[t._v("#")]),t._v(" this 问题")]),t._v(" "),r("p",[t._v("虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。")]),t._v(" "),r("p",[t._v("Reflect 概述\nReflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect 对象的设计目的有这样几个。")]),t._v(" "),r("p",[t._v("（1） 将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。")]),t._v(" "),r("p",[t._v("（2） 修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。")])])}),[],!1,null,null,null);e.default=s.exports}}]);